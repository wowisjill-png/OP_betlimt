<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bet Limit Configuration</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body style="padding-left:20px;">
  <!-- Top Info (non-fixed) -->
  <div class="max-w-7xl mx-auto flex justify-end items-center mb-2">
    <div style="background:rgba(255,255,255,0.95);border-radius:8px;padding:8px 16px;box-shadow:0 2px 8px rgba(0,0,0,0.04);font-size:13px;color:#444;min-width:180px;">
      <div><b>Last Edited Time:</b> 2026-01-21 09:00</div>
      <div><b>Last Editor:</b> admin</div>
    </div>
  </div>
  <!-- Breadcrumb -->
  <nav style="width:100%;background:#f6f8fa;padding:18px 0 10px 0;margin-bottom:8px;">
    <span style="color:#5a6b8a;font-size:14px;font-weight:400;letter-spacing:0.5px;">Game</span>
    <span style="color:#5a6b8a;font-size:14px;font-weight:400;margin:0 12px;">&gt;</span>
    <span style="color:#5a6b8a;font-size:14px;font-weight:400;">Game Setting</span>
  </nav>

  <h1 style="color:#000;font-size:24px;font-weight:500;">Bet Limits</h1>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    
    // Lucide Icons Components
    const Search = (props) => React.createElement('i', { 'data-lucide': 'search', ...props });
    const Save = (props) => React.createElement('i', { 'data-lucide': 'save', ...props });
    const Plus = (props) => React.createElement('i', { 'data-lucide': 'plus', ...props });
    const AlertCircle = (props) => React.createElement('i', { 'data-lucide': 'alert-circle', ...props });
    const Calculator = (props) => React.createElement('i', { 'data-lucide': 'calculator', ...props });
    const Info = (props) => React.createElement('i', { 'data-lucide': 'info', ...props });
    const RefreshCw = (props) => React.createElement('i', { 'data-lucide': 'refresh-cw', ...props });
    const Lock = (props) => React.createElement('i', { 'data-lucide': 'lock', ...props });
    const Shuffle = (props) => React.createElement('i', { 'data-lucide': 'shuffle', ...props });

    // --- Constants & Mock Data ---

const GAMES = ['Baccarat', 'Dragon Tiger', 'Roulette', 'ThaiHiLo', 'ThaiFishPrawnCrab', 'Sedie', 'PokDeng'];
const WEBSITES = ['Home', 'MexA', 'MexB', 'MexC', 'MexD', 'LiveCasino A', 'LiveCasino B'];
const CURRENCIES = ['SGD', 'MYR', 'HKD', 'CNY', 'JPY', 'AUD', 'IDR', 'USD', 'KRW'];

// 幣別顯示格式：Currency ID. Currency Name
const CURRENCY_DISPLAY = {
  SGD: '0. SGD',
  MYR: '1. MYR',
  HKD: '2. HKD',
  CNY: '3. CNY',
  JPY: '4. JPY',
  AUD: '5. AUD',
  IDR: '6. IDR',
  USD: '7. USD',
  KRW: '8. KRW',
  TWD: '10. TWD',
};

// Helper to generate random multiple of 5 between 1 and 50
const getRandomMinChip = () => {
  const min = 1;
  const max = 10; // 5 * 10 = 50
  const randomMultiplier = Math.floor(Math.random() * (max - min + 1)) + min;
  return randomMultiplier * 5;
};

// Mock server data: Currency Minimum Chip Defaults
const MIN_CHIP_DEFAULTS = {
  SGD: 10,
  MYR: 20,
  HKD: 30,
  CNY: 40,
  JPY: 50,
  AUD: 60,
  IDR: 70,
  USD: 80,
  KRW: 1000,
  TWD: 100
};

// Minimum Limit Calculation Ratios
const MIN_RATIOS = {
  bp: 100, tie: 10, pair: 10, bonus: 10, bigSmall: 100, anyPair: 10, perfectPair: 10, superSix: 10, lucky6: 10, bpNature: 10, smallDragon: 10, bigDragon: 10, smallTiger: 10, bigTiger: 10, dragonTiger: 10,
  dragon: 100, tiger: 100,
  bet: 100, direct: 1, separate: 1, street: 1, triangle: 1, corner: 1, fourNumbers: 1, line: 1, column: 1, dozen: 1, redBlack: 100, oddEven: 100,
  high: 100, low: 100, elevenHiLo: 100, point: 100, td: 100, point3: 100, p1AndLo: 100, p2AndLo: 100, p3AndLo: 100, p4AndHi: 100, p5AndHi: 100, p6AndHi: 100,
  fish: 100, prawn: 100, crab: 100, coin: 100, gourd: 100, rooster: 100,
  big: 100, small: 100, odd: 100, even: 100,
  r4: 100, w4: 100, r3w1: 100, w3r1: 100, w2r2: 100, w4r4: 100,
  seatA: 100, seatB: 100, seatC: 100,
  player: 100, banker: 100
};

// Maximum Limit Calculation Ratios
const MAX_RATIOS = {
  bp: 100, tie: 10, pair: 9, bonus: 9, bigSmall: 100, anyPair: 20, perfectPair: 4, superSix: 8, lucky6: 8, bpNature: 9, smallDragon: 9, bigDragon: 9, smallTiger: 9, bigTiger: 9, dragonTiger: 9,
  dragon: 100, tiger: 100,
  bet: 100, direct: 3, separate: 6, street: 10, triangle: 10, corner: 12, fourNumbers: 12, line: 20, column: 50, dozen: 50, redBlack: 100, oddEven: 100,
  high: 90, low: 100, elevenHiLo: 15, point: 30, td: 20, point3: 20, p1AndLo: 55, p2AndLo: 50, p3AndLo: 30, p4AndHi: 25, p5AndHi: 30, p6AndHi: 50,
  fish: 100, prawn: 100, crab: 100, coin: 100, gourd: 100, rooster: 100,
  big: 100, small: 100, odd: 100, even: 100,
  r4: 10, w4: 10, r3w1: 30, w3r1: 30, w2r2: 50, w4r4: 30,
  seatA: 30, seatB: 30, seatC: 30,
  player: 100, banker: 100
};

// Game-specific limit fields
const GAME_LIMIT_FIELDS = {
  'Baccarat': {
    fields: ['bp', 'tie', 'pair', 'bonus', 'bigSmall', 'anyPair', 'perfectPair', 'lucky6', 'bpNature', 'smallBigTiger', 'smallBigDragon', 'dragonTiger'],
    config: {
      bp: { displayName: 'Banker/Player', isMain: true },
      tie: { displayName: 'Tie' },
      pair: { displayName: 'B/P Pair' },
      bonus: { displayName: 'B/P Bonus' },
      bigSmall: { displayName: 'Big/Small' },
      anyPair: { displayName: 'Any Pair' },
      perfectPair: { displayName: 'Perfect Pair' },
      lucky6: { displayName: 'Lucky 6' },
      bpNature: { displayName: 'B/P Nature' },
      smallBigTiger: { displayName: 'Small/Big Tiger' },
      smallBigDragon: { displayName: 'Small/Big Dragon' },
      dragonTiger: { displayName: 'Dragon Tiger' }
    }
  },
  'Dragon Tiger': {
    fields: ['dragon', 'tiger', 'tie'],
    config: {
      dragon: { displayName: 'Dragon', isMain: true },
      tiger: { displayName: 'Tiger', isMain: true },
      tie: { displayName: 'Tie' }
    }
  },
  'Roulette': {
    fields: ['bet', 'direct', 'separate', 'street', 'triangle', 'corner', 'fourNumbers', 'line', 'column', 'dozen', 'redBlack', 'oddEven', 'bigSmall'],
    config: {
      bet: { displayName: 'Bet', isMain: true },
      direct: { displayName: 'Direct' },
      separate: { displayName: 'Separate' },
      street: { displayName: 'Street' },
      triangle: { displayName: 'Triangle' },
      corner: { displayName: 'Corner' },
      fourNumbers: { displayName: 'FourNumbers' },
      line: { displayName: 'Line' },
      column: { displayName: 'Column' },
      dozen: { displayName: 'Dozen' },
      redBlack: { displayName: 'RedBlack' },
      oddEven: { displayName: 'OddEven' },
      bigSmall: { displayName: 'BigSmall' }
    }
  },
  'ThaiHiLo': {
    fields: ['bet', 'high', 'low', 'elevenHiLo', 'point', 'td', 'point3', 'p1AndLo', 'p2AndLo', 'p3AndLo', 'p4AndHi', 'p5AndHi', 'p6AndHi'],
    config: {
      bet: { displayName: 'Bet', isMain: true },
      high: { displayName: 'Hi' },
      low: { displayName: 'Lo' },
      elevenHiLo: { displayName: 'ElevenHiLo' },
      point: { displayName: 'Point' },
      td: { displayName: 'Td' },
      point3: { displayName: 'Point3' },
      p1AndLo: { displayName: 'P1AndLo' },
      p2AndLo: { displayName: 'P2AndLo' },
      p3AndLo: { displayName: 'P3AndLo' },
      p4AndHi: { displayName: 'P4AndHi' },
      p5AndHi: { displayName: 'P5AndHi' },
      p6AndHi: { displayName: 'P6AndHi' }
    }
  },
  'ThaiFishPrawnCrab': {
    fields: ['bet', 'point', 'td'],
    config: {
      bet: { displayName: 'Bet', isMain: true },
      point: { displayName: 'Point' },
      td: { displayName: 'Td' }
    }
  },
  'Sedie': {
    fields: ['bet', 'bigSmall', 'oddEven', 'r4', 'w4', 'r3w1', 'w3r1', 'w2r2', 'w4r4'],
    config: {
      bet: { displayName: 'Bet', isMain: true },
      bigSmall: { displayName: 'Big/Small' },
      oddEven: { displayName: 'Odd/Even' },
      r4: { displayName: '4R' },
      w4: { displayName: '4W' },
      r3w1: { displayName: '3R1W' },
      w3r1: { displayName: '3W1R' },
      w2r2: { displayName: '2W2R' },
      w4r4: { displayName: '4W4R' }
    }
  },
  'PokDeng': {
    fields: ['bet', 'seatA', 'seatB', 'seatC'],
    config: {
      bet: { displayName: 'Bet', isMain: true },
      seatA: { displayName: 'Seat A' },
      seatB: { displayName: 'Seat B' },
      seatC: { displayName: 'Seat C' }
    }
  }
};

// Update MIN_RATIOS and MAX_RATIOS to include all game fields
// (This block is now redundant as we defined them above, but keeping for safety if I missed any)
Object.assign(MIN_RATIOS, {
  // ... existing assignments if needed, but we defined them in the const declaration
});

Object.assign(MAX_RATIOS, {
  // ... existing assignments if needed
});

// Get initial limits for selected game
const getInitialLimitsForGame = (game) => {
  if (!game || !GAME_LIMIT_FIELDS[game]) {
    return { bp: { min: '', max: '' }, tie: { min: '', max: '' }, pair: { min: '', max: '' }, bonus: { min: '', max: '' }, bigSmall: { min: '', max: '' }, anyPair: { min: '', max: '' }, perfectPair: { min: '', max: '' }, superSix: { min: '', max: '' }, lucky6: { min: '', max: '' }, bpNature: { min: '', max: '' }, smallDragon: { min: '', max: '' }, bigDragon: { min: '', max: '' }, smallTiger: { min: '', max: '' }, bigTiger: { min: '', max: '' }, dragonTiger: { min: '', max: '' } };
  }
  
  const fields = GAME_LIMIT_FIELDS[game].fields;
  const limits = {};
  fields.forEach(key => {
    limits[key] = { min: '', max: '' };
  });
  return limits;
};

// Mock Initial Data - IDs start from 10001 (5 digits)
const MOCK_DATA = [
  // LiveCasino_A examples
  {
    id: '10001', game: 'Baccarat', website: 'LiveCasino_A', currency: 'USD', minChip: 5, status: 'Enable',
    limits: { bp: { min: 100, max: 10000 }, tie: { min: 10, max: 1000 }, pair: { min: 10, max: 900 }, bonus: { min: 10, max: 900 }, bigSmall: { min: 100, max: 10000 }, anyPair: { min: 10, max: 2000 }, perfectPair: { min: 10, max: 400 }, superSix: { min: 10, max: 800 }, lucky6: { min: 10, max: 800 }, bpNature: { min: 10, max: 900 }, smallDragon: { min: 10, max: 900 }, bigDragon: { min: 10, max: 900 }, smallTiger: { min: 10, max: 900 }, bigTiger: { min: 10, max: 900 }, dragonTiger: { min: 10, max: 900 } },
  },
  {
    id: '10002', game: 'Baccarat', website: 'LiveCasino_A', currency: 'CNY', minChip: 20, status: 'Disable',
    limits: { bp: { min: 500, max: 50000 }, tie: { min: 50, max: 5000 }, pair: { min: 50, max: 4500 }, bonus: { min: 50, max: 4500 }, bigSmall: { min: 500, max: 50000 }, anyPair: { min: 50, max: 10000 }, perfectPair: { min: 50, max: 2000 }, superSix: { min: 50, max: 4000 }, lucky6: { min: 50, max: 4000 }, bpNature: { min: 50, max: 4500 }, smallDragon: { min: 50, max: 4500 }, bigDragon: { min: 50, max: 4500 }, smallTiger: { min: 50, max: 4500 }, bigTiger: { min: 50, max: 4500 }, dragonTiger: { min: 50, max: 4500 } },
  },
  {
    id: '10501', game: 'Baccarat', website: 'Home', currency: 'SGD', minChip: 10, status: 'Enable',
    limits: { bp: { min: 30, max: 10000 }, tie: { min: 10, max: 1000 }, pair: { min: 10, max: 900 }, bonus: { min: 10, max: 900 }, bigSmall: { min: 30, max: 10000 }, anyPair: { min: 10, max: 2000 }, perfectPair: { min: 10, max: 400 }, superSix: { min: 10, max: 800 }, lucky6: { min: 10, max: 800 }, bpNature: { min: 10, max: 900 }, smallDragon: { min: 10, max: 900 }, bigDragon: { min: 10, max: 900 }, smallTiger: { min: 10, max: 900 }, bigTiger: { min: 10, max: 900 }, dragonTiger: { min: 10, max: 900 } },
  },
  {
    id: '10601', game: 'Baccarat', website: 'Home', currency: 'CNY', minChip: 40, status: 'Enable',
    limits: { bp: { min: 40, max: 55555 }, tie: { min: 40, max: 5555 }, pair: { min: 40, max: 4999 }, bonus: { min: 40, max: 4999 }, bigSmall: { min: 40, max: 55555 }, anyPair: { min: 40, max: 11111 }, perfectPair: { min: 40, max: 2222 }, superSix: { min: 40, max: 4444 }, lucky6: { min: 40, max: 4444 }, bpNature: { min: 40, max: 4999 }, smallDragon: { min: 40, max: 4999 }, bigDragon: { min: 40, max: 4999 }, smallTiger: { min: 40, max: 4999 }, bigTiger: { min: 40, max: 4999 }, dragonTiger: { min: 40, max: 4999 } },
  },
  {
    id: '10503', game: 'Baccarat', website: 'Home', currency: 'SGD', minChip: 10, status: 'Enable',
    limits: { bp: { min: 31, max: 344400 }, tie: { min: 10, max: 34440 }, pair: { min: 10, max: 30996 }, bonus: { min: 10, max: 30996 }, bigSmall: { min: 31, max: 344400 }, anyPair: { min: 10, max: 68880 }, perfectPair: { min: 10, max: 13776 }, superSix: { min: 10, max: 27552 }, lucky6: { min: 10, max: 27552 }, bpNature: { min: 10, max: 30996 }, smallDragon: { min: 10, max: 30996 }, bigDragon: { min: 10, max: 30996 }, smallTiger: { min: 10, max: 30996 }, bigTiger: { min: 10, max: 30996 }, dragonTiger: { min: 10, max: 30996 } },
  },
  {
    id: '10503', game: 'Dragon Tiger', website: 'Home', currency: 'SGD', minChip: 10, status: 'Enable',
    limits: { dragon: { min: 31, max: 344400 }, tiger: { min: 31, max: 344400 }, tie: { min: 10, max: 34440 } },
  },
  {
    id: '10503', game: 'Roulette', website: 'Home', currency: 'SGD', minChip: 10, status: 'Enable',
    limits: { bet: { min: 31, max: 344400 }, direct: { min: 10, max: 10332 }, separate: { min: 10, max: 20664 }, street: { min: 10, max: 34440 }, triangle: { min: 10, max: 34440 }, corner: { min: 10, max: 41328 }, fourNumbers: { min: 10, max: 41328 }, line: { min: 10, max: 68880 }, column: { min: 10, max: 172200 }, dozen: { min: 10, max: 172200 }, redBlack: { min: 31, max: 344400 }, oddEven: { min: 31, max: 344400 } },
  },
  {
    id: '10503', game: 'Sedie', website: 'Home', currency: 'SGD', minChip: 10, status: 'Enable',
    limits: { bet: { min: 31, max: 344400 }, bigSmall: { min: 31, max: 344400 }, oddEven: { min: 31, max: 344400 }, r4: { min: 31, max: 34440 }, w4: { min: 31, max: 34440 }, r3w1: { min: 31, max: 103320 }, w3r1: { min: 31, max: 103320 }, w2r2: { min: 31, max: 172200 }, w4r4: { min: 31, max: 103320 } },
  },
  {
    id: '10503', game: 'ThaiHiLo', website: 'Home', currency: 'SGD', minChip: 10, status: 'Enable',
    limits: { bet: { min: 31, max: 344400 }, high: { min: 31, max: 309960 }, low: { min: 31, max: 344400 }, elevenHiLo: { min: 31, max: 51660 }, point: { min: 31, max: 103320 }, td: { min: 31, max: 68880 }, point3: { min: 31, max: 68880 }, p1AndLo: { min: 31, max: 189420 }, p2AndLo: { min: 31, max: 172200 }, p3AndLo: { min: 31, max: 103320 }, p4AndHi: { min: 31, max: 86100 }, p5AndHi: { min: 31, max: 103320 }, p6AndHi: { min: 31, max: 172200 } },
  },
  {
    id: '10503', game: 'ThaiFishPrawnCrab', website: 'Home', currency: 'SGD', minChip: 10, status: 'Enable',
    limits: { bet: { min: 31, max: 344400 }, point: { min: 31, max: 103320 }, td: { min: 31, max: 68880 } },
  },
  {
    id: '10503', game: 'PokDeng', website: 'Home', currency: 'SGD', minChip: 10, status: 'Enable',
    limits: { bet: { min: 31, max: 344400 }, seatA: { min: 31, max: 103320 }, seatB: { min: 31, max: 103320 }, seatC: { min: 31, max: 103320 } },
  },
  {
    id: '10003', game: 'Dragon Tiger', website: 'LiveCasino_A', currency: 'USD', minChip: 5, status: 'Enable',
    limits: { dragon: { min: 100, max: 10000 }, tiger: { min: 100, max: 10000 }, tie: { min: 10, max: 1000 } },
  },

  // LiveCasino_B examples
  {
    id: '10004', game: 'Baccarat', website: 'LiveCasino_B', currency: 'HKD', minChip: 20, status: 'Enable',
    limits: { bp: { min: 200, max: 20000 }, tie: { min: 20, max: 2000 }, pair: { min: 20, max: 1800 }, bonus: { min: 20, max: 1800 }, bigSmall: { min: 200, max: 20000 }, anyPair: { min: 20, max: 4000 }, perfectPair: { min: 20, max: 800 }, superSix: { min: 20, max: 1600 } },
  },
  {
    id: '10005', game: 'Roulette', website: 'LiveCasino_B', currency: 'JPY', minChip: 500, status: 'Disable',
    limits: { straight: { min: 1000, max: 100000 }, split: { min: 500, max: 50000 }, corner: { min: 250, max: 25000 }, red: { min: 1000, max: 100000 }, black: { min: 1000, max: 100000 }, odd: { min: 1000, max: 100000 }, even: { min: 1000, max: 100000 } },
  },

  // Sportsbook examples
  {
    id: '10006', game: 'ThaiHiLo', website: 'Sportsbook', currency: 'SGD', minChip: 10, status: 'Enable',
    limits: { high: { min: 50, max: 5000 }, low: { min: 50, max: 5000 }, tie: { min: 5, max: 500 } },
  },
  {
    id: '10007', game: 'ThaiFishPrawnCrab', website: 'Sportsbook', currency: 'TWD', minChip: 100, status: 'Enable',
    limits: { fish: { min: 500, max: 50000 }, prawn: { min: 500, max: 50000 }, crab: { min: 500, max: 50000 }, coin: { min: 500, max: 50000 }, gourd: { min: 500, max: 50000 }, rooster: { min: 500, max: 50000 } },
  },

  // Gamelobby examples
  {
    id: '10008', game: 'Sedie', website: 'Gamelobby', currency: 'USD', minChip: 5, status: 'Enable',
    limits: { big: { min: 80, max: 8000 }, small: { min: 80, max: 8000 }, odd: { min: 80, max: 8000 }, even: { min: 80, max: 8000 } },
  },
  {
    id: '10009', game: 'PokDeng', website: 'Gamelobby', currency: 'CNY', minChip: 20, status: 'Disable',
    limits: { player: { min: 400, max: 40000 }, banker: { min: 400, max: 40000 } },
  },
  {
    id: '10010', game: 'Dragon Tiger', website: 'Gamelobby', currency: 'TWD', minChip: 100, status: 'Disable',
    limits: { dragon: { min: 1000, max: 10000 }, tiger: { min: 1000, max: 10000 }, tie: { min: 100, max: 1000 } },
  }
];

// --- Helper Functions ---

/** Converts a number to a localized string with commas. */
const formatNumber = (num) => {
  if (num === '' || num === undefined || num === null || isNaN(num)) return '';
  // Convert to number for proper formatting
  return Number(num).toLocaleString('en-US'); 
};

/** Parses a comma-separated string back to a pure number (or empty string). */
const parseNumber = (str) => {
  if (!str) return '';
  // 1. Remove commas and non-digit characters
  const cleanStr = str.toString().replace(/[^0-9]/g, ''); 
  if (cleanStr === '') return '';
  
  const parsed = Number(cleanStr);
  // Return the number or empty string
  return isNaN(parsed) ? '' : parsed; 
};

/** Extracts the numeric part of the ID and calculates the next sequential 5-digit ID based on currency. */
const getNextBetLimitId = (currentData, currency, website) => {
  let startId, endId;

  switch (currency) {
    case 'USD':
      startId = 10000;
      endId = 10100;
      break;
    case 'CNY':
      startId = 10101;
      endId = 10200;
      break;
    case 'HKD':
      startId = 10201;
      endId = 10300;
      break;
    case 'JPY':
      startId = 10301;
      endId = 10400;
      break;
    case 'TWD':
      startId = 10401;
      endId = 10500;
      break;
    case 'SGD':
      startId = 10501;
      endId = 10600;
      break;
    default:
      // Default range for other currencies or if not specified
      startId = 10601;
      endId = 99999;
  }

  // Find all used IDs in the target range, filtered by Website
  const usedIds = currentData
    .filter(d => d.website === website) // Only check IDs used by this website
    .map(d => parseInt(d.id, 10))
    .filter(id => !isNaN(id) && id >= startId && id <= endId)
    .sort((a, b) => a - b);

  if (usedIds.length === 0) {
    return startId.toString();
  }

  // Find the first gap
  let nextId = startId;
  for (let i = 0; i < usedIds.length; i++) {
    if (usedIds[i] === nextId) {
      nextId++;
    } else if (usedIds[i] > nextId) {
      // Found a gap
      return nextId.toString();
    }
  }
  
  // If no gap, nextId is already max + 1 of the used ones.
  // Check if it exceeds endId
  if (nextId > endId) {
    // Range full, fallback to finding max of all + 1 to avoid collision, or just return nextId
    // For now, return nextId even if it exceeds range, to ensure uniqueness
    return nextId.toString(); 
  }

  return nextId.toString();
};


// --- Components ---

const LimitInputGroup = ({ title, minVal, maxVal, onMinChange, onMaxChange, isMain = false, minChipLimit, minRatio, maxRatio, baseMinLimit, disabled = false }) => {
  const min = parseNumber(minVal);
  const max = parseNumber(maxVal);
  
  // Calculate the expected base min for this bet type based on ratio
  const calculatedBaseMin = baseMinLimit && baseMinLimit !== '' ? Math.floor(Number(baseMinLimit) * (minRatio / 100)) : 0;
  // Calculate the expected base max for this bet type based on ratio
  const calculatedBaseMax = baseMinLimit && baseMinLimit !== '' ? Math.floor(Number(baseMinLimit) * (maxRatio / 100)) : 0;
  
  // Only validate if values are entered AND minChipLimit is greater than 0
  const isMinError = min !== '' && ((minChipLimit > 0 && min < minChipLimit) || (calculatedBaseMin > 0 && min < calculatedBaseMin));
  const isMaxError = max !== '' && ((calculatedBaseMin > 0 && max < calculatedBaseMin) || (min !== '' && max < min));

  return (
    <div className={`flex flex-col p-3 rounded border bg-gray-50 border-gray-200`}>
      {/* Title and Ratios - Fixed height */}
      <div className={`text-center mb-2 text-gray-500 font-medium`}>
        <div className="text-sm font-semibold h-5 flex items-center justify-center">{title}</div>
      </div>
      
      {/* Min/Max Input Container - Flex grow to push inputs to bottom */}
      <div className="flex-1 flex flex-col justify-end gap-2">
        {/* Min Limit Input */}
        <div>
          <div className="flex items-center gap-1">
            <span className="w-8 text-right font-semibold" style={{color: 'rgb(156,163,175)', fontSize: '8px'}}>Min<br/>{minRatio}%</span>
            <input
              type="text"
              value={formatNumber(minVal)}
              onChange={(e) => onMinChange(parseNumber(e.target.value))}
              readOnly={disabled}
              disabled={disabled}
              className={`w-full text-right p-1.5 text-sm border rounded focus:ring-1 focus:outline-none transition-all
                border-gray-300 focus:border-blue-500
                ${isMinError ? 'border-red-500 bg-red-50 focus:ring-red-200' : ''}
                ${disabled ? 'opacity-60 bg-gray-50 cursor-not-allowed' : ''}
              `}
              placeholder=""
            />
          </div>
          <div className="h-3.5 mt-0.5">
            {isMinError && (
              <div className="flex items-center gap-1 text-red-500" style={{textAlign: 'right', paddingLeft: '2rem', fontWeight: 500, fontSize: '8px'}}>
                Must be ≥ Min Chip
              </div>
            )}
          </div>
        </div>

        {/* Max Limit Input */}
        <div>
          <div className="flex items-center gap-1">
            <span className="w-8 text-right font-semibold" style={{color: 'rgb(156,163,175)', fontSize: '8px'}}>Max<br/>{maxRatio}%</span>
            <input
              type="text"
              value={formatNumber(maxVal)}
              onChange={(e) => onMaxChange(parseNumber(e.target.value))}
              readOnly={disabled}
              disabled={disabled}
              className={`w-full text-right p-1.5 text-sm border rounded focus:ring-1 focus:outline-none transition-all
                border-gray-300 focus:border-blue-500
                ${isMaxError ? 'border-red-500 bg-red-50 focus:ring-red-200' : ''}
                ${disabled ? 'opacity-60 bg-gray-50 cursor-not-allowed' : ''}
              `}
              placeholder=""
            />
          </div>
          <div className="h-3.5 mt-0.5">
            {isMaxError && (
              <div className="flex items-center gap-1 text-red-500" style={{textAlign: 'right', paddingLeft: '2rem', fontWeight: 500, fontSize: '8px'}}>
                Must be &gt; Min Limit
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

const App = () => {
    // Quick Auto-Calculation handler for Create New Bet Limit
    const handleBaseValueChange = (type, value) => {
      if (!newLimit.currency) {
        showNotification('Please select a Currency first.', 'error');
        return;
      }
      const numVal = parseNumber(value);
      // The value to use for calculation (use 0 if input is empty)
      const baseValue = numVal !== '' ? Number(numVal) : 0;
      // Select the correct ratio map
      const ratios = type === 'min' ? MIN_RATIOS : MAX_RATIOS;
      if (type === 'min') setBaseMin(numVal);
      else setBaseMax(numVal);
      // Auto-fill logic
      const updatedLimits = { ...newLimit.limits };
      if (batchMode) {
        // Update all games in batch mode
        GAMES.forEach(game => {
          if (!updatedLimits[game]) updatedLimits[game] = {};
          const gameFields = GAME_LIMIT_FIELDS[game].fields;
          gameFields.forEach(fieldName => {
            // Default to 100 if ratio is missing, matching UI behavior
            const ratioVal = ratios[fieldName] !== undefined ? ratios[fieldName] : 100;
            const ratio = ratioVal / 100;
            let calculatedValue = Math.floor(baseValue * ratio);
            if (!updatedLimits[game][fieldName]) updatedLimits[game][fieldName] = { min: '', max: '' };
            if (type === 'min') {
              // If calculated min is less than currency min chip, use currency min chip
              if (newLimit.minChip > 0 && calculatedValue < newLimit.minChip) {
                calculatedValue = newLimit.minChip;
              }
              updatedLimits[game][fieldName].min = numVal === '' ? '' : calculatedValue;
            } else {
              updatedLimits[game][fieldName].max = numVal === '' ? '' : calculatedValue;
            }
          });
        });
      } else if (newLimit.game && GAME_LIMIT_FIELDS[newLimit.game]) {
        // Update single game
        if (!updatedLimits[newLimit.game]) updatedLimits[newLimit.game] = {};
        const gameFields = GAME_LIMIT_FIELDS[newLimit.game].fields;
        gameFields.forEach(fieldName => {
          if (!updatedLimits[newLimit.game][fieldName]) updatedLimits[newLimit.game][fieldName] = { min: '', max: '' };
          // Default to 100 if ratio is missing
          const ratioVal = ratios[fieldName] !== undefined ? ratios[fieldName] : 100;
          const ratio = ratioVal / 100;
          let calculatedValue = Math.floor(baseValue * ratio);
          if (type === 'min') {
            // If calculated min is less than currency min chip, use currency min chip
            if (newLimit.minChip > 0 && calculatedValue < newLimit.minChip) {
              calculatedValue = newLimit.minChip;
            }
            updatedLimits[newLimit.game][fieldName].min = numVal === '' ? '' : calculatedValue;
          } else {
            updatedLimits[newLimit.game][fieldName].max = numVal === '' ? '' : calculatedValue;
          }
        });
      }
      setNewLimit(prev => ({ ...prev, limits: updatedLimits }));
    };
  const [activeTab, setActiveTab] = useState('search'); // 'search' | 'create'
  const [data, setData] = useState(MOCK_DATA);
  const [notification, setNotification] = useState(null);
  const notificationTimerRef = useRef(null);

  // --- Create Form State ---
  const [newLimit, setNewLimit] = useState({
    id: '',
    game: '',
    website: '',
    currency: '', // Currency defaults to empty
    minChip: 0, // Initialized to 0, updated when currency is selected
    limits: getInitialLimitsForGame(''),
  });
  
  // Batch creation state
  const [batchMode, setBatchMode] = useState(true);

  // Update limits when game changes or batch mode changes
  useEffect(() => {
    if (batchMode) {
      // Initialize limits for all games in batch mode
      const allGameLimits = {};
      GAMES.forEach(game => {
        allGameLimits[game] = getInitialLimitsForGame(game);
      });
      setNewLimit(prev => ({
        ...prev,
        limits: allGameLimits
      }));
    } else if (newLimit.game) {
      setNewLimit(prev => ({
        ...prev,
        limits: getInitialLimitsForGame(prev.game)
      }));
    }
  }, [newLimit.game, batchMode]);
  
  // Auto Calc inputs for Create Form
  const [baseMin, setBaseMin] = useState(''); // Base min limit (pure number input)
  const [baseMax, setBaseMax] = useState(''); // Base max limit (pure number input)

  // Auto Calc inputs for Search Form
  const [searchBaseMin, setSearchBaseMin] = useState('');
  const [searchBaseMax, setSearchBaseMax] = useState('');

  // --- Search State ---
  const [searchFilters, setSearchFilters] = useState({
    id: '',
    game: '',
    website: '',
    currency: ''
  });
  const [searchResults, setSearchResults] = useState([]);
  const [hasSearched, setHasSearched] = useState(false);
  const [saveStatus, setSaveStatus] = useState({});
  const [createStatus, setCreateStatus] = useState(null); // 'success' | 'failed'
  const [saveAllStatus, setSaveAllStatus] = useState(null); // 'success' | 'failed'

  // Ensure lucide replaces <i data-lucide> elements with SVG after render
  useEffect(() => {
    if (window.lucide && typeof window.lucide.createIcons === 'function') {
      try {
        window.lucide.createIcons();
      } catch (e) {
        // swallow errors - lucide availability can be intermittent in dev
        // console.warn('lucide.createIcons failed', e);
      }
    }
  }, [activeTab, searchResults]);

  // Reset to Batch Mode when switching to Create tab
  useEffect(() => {
    if (activeTab === 'create') {
      setBatchMode(true);
      setNewLimit(prev => ({ ...prev, game: '' }));
    }
  }, [activeTab]);

  // --- Notification Helper ---
  const showNotification = (msg, type = 'success', autoDismiss = true) => {
    // clear any existing timer
    if (notificationTimerRef.current) {
      clearTimeout(notificationTimerRef.current);
      notificationTimerRef.current = null;
    }

    setNotification({ msg, type, autoDismiss });

    if (autoDismiss) {
      notificationTimerRef.current = setTimeout(() => {
        setNotification(null);
        notificationTimerRef.current = null;
      }, 3000);
    }
  };

  // --- Logic: Simulate Server Min Chip Fetch ---
  useEffect(() => {
    if (activeTab === 'create' && newLimit.currency) {
        // Only update minChip if a currency is selected
        const serverMinChip = MIN_CHIP_DEFAULTS[newLimit.currency] || 0;
        setNewLimit(prev => ({ ...prev, minChip: serverMinChip }));
    } else if (activeTab === 'create' && !newLimit.currency) {
        // When currency is empty, set minChip to 0 for validation purposes
        setNewLimit(prev => ({ ...prev, minChip: 0 }));
    }
  }, [newLimit.currency, activeTab]);

  // --- Logic: Generate ID ---
  const generateId = () => {
    if (!newLimit.website) {
      showNotification('Please select a Website first.', 'error');
      return;
    }
    if (!newLimit.currency) {
      showNotification('Please select a Currency first.', 'error');
      return;
    }
    // 產生下一個可用的 Bet Limit ID
    const nextId = getNextBetLimitId(data, newLimit.currency, newLimit.website);
    setNewLimit(prev => ({ ...prev, id: nextId }));
  };
  
  // --- Logic: Create ---
  const handleCreateSubmit = () => {
    // 單筆建立檢查順序與訊息與批次一致
    if (!batchMode && !newLimit.game) return showNotification('Please select a Game.', 'error');
    if (!newLimit.website) return showNotification('Please select a Website.', 'error');
    if (!newLimit.currency) return showNotification('Please select a Currency.', 'error');

    if (batchMode) {
      // Batch creation logic
      return handleBatchCreate();
    }

    // 單筆建立檢查
    // 1. ID 必填
    if (!newLimit.id) {
      return showNotification('Bet Limit ID is empty.', 'error');
    }
    // 2. ID 必須為 5 位數字
    if (!/^[0-9]{5}$/.test(newLimit.id)) {
      return showNotification('Bet Limit ID must be a 5-digit number.', 'error');
    }
    // 2. ID 同一遊戲裡有重複
    const exists = data.some(d => String(d.id) === String(newLimit.id) && d.website === newLimit.website && d.game === newLimit.game);
    if (exists) return showNotification('Bet Limit ID already used.', 'error');

    // 3. 任一 bet area min/max 為空
    let emptyField = false, minChipError = false, minMaxError = false;
    const currentMinChip = newLimit.currency ? MIN_CHIP_DEFAULTS[newLimit.currency] : 0;
    // 檢查所有注區（支援單一遊戲 limits 結構）
    if (batchMode) {
      Object.entries(newLimit.limits).forEach(([game, fields]) => {
        Object.entries(fields).forEach(([key, val]) => {
          const minValNum = parseNumber(val.min) === '' ? null : Number(parseNumber(val.min));
          const maxValNum = parseNumber(val.max) === '' ? null : Number(parseNumber(val.max));
          if (minValNum === null || maxValNum === null) emptyField = true;
          if (minValNum !== null && minValNum < currentMinChip) minChipError = true;
          if (minValNum !== null && maxValNum !== null && maxValNum <= minValNum) minMaxError = true;
        });
      });
    } else if (newLimit.game && newLimit.limits[newLimit.game]) {
      Object.entries(newLimit.limits[newLimit.game]).forEach(([key, val]) => {
        const minValNum = parseNumber(val.min) === '' ? null : Number(parseNumber(val.min));
        const maxValNum = parseNumber(val.max) === '' ? null : Number(parseNumber(val.max));
        if (minValNum === null || maxValNum === null) emptyField = true;
        if (minValNum !== null && minValNum < currentMinChip) minChipError = true;
        if (minValNum !== null && maxValNum !== null && maxValNum <= minValNum) minMaxError = true;
      });
    }
    if (emptyField) return showNotification('All bet limit fields must be filled.', 'error');
    if (minChipError) return showNotification('Min must be ≥ Min Chip.', 'error');
    if (minMaxError) return showNotification('Max must be > Min.', 'error');

    const finalId = newLimit.id || getNextBetLimitId(data, newLimit.currency, newLimit.website);

    // Prepare payload for saving
    const payload = {
      ...newLimit,
      id: finalId,
      game: newLimit.game,
      status: 'Enable',
      // Ensure the minChip saved is the correct one based on currency
      minChip: currentMinChip, 
    };

    // Convert limits to numbers (or empty string if empty)
    const limitsToSave = JSON.parse(JSON.stringify(newLimit.limits));
    Object.keys(limitsToSave).forEach(key => {
        limitsToSave[key].min = parseNumber(limitsToSave[key].min) !== '' ? Number(parseNumber(limitsToSave[key].min)) : '';
        limitsToSave[key].max = parseNumber(limitsToSave[key].max) !== '' ? Number(parseNumber(limitsToSave[key].max)) : '';
    });
    payload.limits = limitsToSave;

    setData(prev => [...prev, payload]);
    showNotification(`Bet Limit ${finalId} created successfully!`);
    setCreateStatus('success');
    setTimeout(() => setCreateStatus(null), 3000);
    
    // Reset form
    setNewLimit({
      id: '', game: '', website: '', currency: '', minChip: 0, limits: getInitialLimitsForGame(''),
    });
    setBaseMin('');
    setBaseMax('');
    setBatchMode(true);
  };
  const handleBatchCreate = () => {
    const currentMinChip = newLimit.currency ? MIN_CHIP_DEFAULTS[newLimit.currency] : 0;

    // Check if limits are configured (check if any game has limits set)
    const hasLimits = Object.keys(newLimit.limits).length > 0;
    if (!hasLimits) {
      setCreateStatus('failed');
      setTimeout(() => setCreateStatus(null), 3000);
      return showNotification('Please configure bet limits before batch creation.', 'error');
    }

    // --- Validation: All games must have valid limits ---
    // Error priority: 1>2>3>4>5>6
    let errorMsg = '';
    const idToCheck = newLimit.id;
    let idUsed = false;
    let emptyField = false, minChipError = false, minMaxError = false;
    if (idToCheck && data.some(d => String(d.id) === String(idToCheck) && d.website === newLimit.website)) idUsed = true;
    GAMES.forEach(game => {
      const gameLimits = newLimit.limits[game];
      if (!gameLimits) return;
      Object.entries(gameLimits).forEach(([key, val]) => {
        const minVal = val.min;
        const maxVal = val.max;
        const minValNum = parseNumber(minVal) === '' ? null : Number(parseNumber(minVal));
        const maxValNum = parseNumber(maxVal) === '' ? null : Number(parseNumber(maxVal));
        if (minVal === '' || maxVal === '' || minVal === undefined || maxVal === undefined) emptyField = true;
        if (minValNum !== null && minValNum < currentMinChip) minChipError = true;
        if (minValNum !== null && maxValNum !== null && maxValNum <= minValNum) minMaxError = true;
      });
    });
    // 1. Bet Limit ID is required
    if (!idToCheck) errorMsg = 'Bet Limit ID is required.';
    // 2. Bet Limit ID must be 5 digits
    else if (!/^[0-9]{5}$/.test(idToCheck)) errorMsg = 'Bet Limit ID must be a 5-digit number.';
    // 3. Bet Limit ID already used
    else if (idUsed) errorMsg = 'Bet Limit ID already used.';
    // 4. Any bet area min/max is empty
    else if (emptyField) errorMsg = 'All bet limit fields must be filled.';
    // 5. Min < Min Chip
    else if (minChipError) errorMsg = 'Min must be ≥ Min Chip.';
    // 6. Max ≤ Min
    else if (minMaxError) errorMsg = 'Max must be > Min.';
    if (errorMsg) {
      setCreateStatus(null); // do not show 'Failed'
      setTimeout(() => setCreateStatus(null), 3000);
      return showNotification(errorMsg, 'error');
    }

    const newItems = [];
    const updatedItems = [];
    const updatedData = [...data]; // Clone data for updates

    // Generate one ID for the whole batch if needed
    let batchId = null;

    // Process all games
    GAMES.forEach(game => {
      // Check if combination already exists
      const existingIndex = updatedData.findIndex(d =>
        d.game === game &&
        d.website === newLimit.website &&
        d.currency === newLimit.currency
      );

      // Get limits for this specific game from the batch configuration
      const gameLimits = newLimit.limits[game];
      if (!gameLimits) return;

      // Prepare limits object with number conversion
      const processedLimits = JSON.parse(JSON.stringify(gameLimits));
      Object.keys(processedLimits).forEach(key => {
        processedLimits[key].min = parseNumber(processedLimits[key].min) !== '' ? Number(parseNumber(processedLimits[key].min)) : '';
        processedLimits[key].max = parseNumber(processedLimits[key].max) !== '' ? Number(parseNumber(processedLimits[key].max)) : '';
      });

      if (existingIndex >= 0) {
        // UPDATE existing
        updatedData[existingIndex] = {
          ...updatedData[existingIndex],
          minChip: currentMinChip,
          limits: processedLimits,
          // Keep existing ID and Status
        };
        updatedItems.push(updatedData[existingIndex].id);
      } else {
        // CREATE new
        if (!batchId) {
          // Calculate ID only once based on current data
          batchId = getNextBetLimitId(updatedData, newLimit.currency, newLimit.website);
        }

        const payload = {
          id: batchId,
          game,
          website: newLimit.website,
          currency: newLimit.currency,
          status: 'Enable',
          minChip: currentMinChip,
          limits: processedLimits
        };
        newItems.push(payload);
      }
    });

    // Update state with both updated existing items and new items
    const finalData = [...updatedData, ...newItems];
    setData(finalData);

    showNotification('Successfully created all games.', 'success');
    setCreateStatus('success');
    setTimeout(() => setCreateStatus(null), 3000);

    // Reset form
    setNewLimit({
      id: '', game: '', website: '', currency: '', minChip: 0, limits: getInitialLimitsForGame(''),
    });
    setBaseMin('');
    setBaseMax('');
    setBatchMode(true);
    // Stay on create tab
  };

  // --- Logic: Search ---
  const handleSearch = () => {
    if (!searchFilters.website) {
      showNotification('Please select a Website first.', 'error');
      return;
    }

    let results = data;

    // Filter by ID first if present
    if (searchFilters.id) {
      results = results.filter(item => item.id.toLowerCase().includes(searchFilters.id.toLowerCase()));
    }
    
    // Apply other filters conjunctively
    if (searchFilters.website) {
      results = results.filter(item => item.website === searchFilters.website);
    }
    if (searchFilters.game) {
      results = results.filter(item => item.game === searchFilters.game);
    }
    if (searchFilters.currency) {
      results = results.filter(item => item.currency === searchFilters.currency);
    }

    results.sort((a, b) => a.id.localeCompare(b.id));

    // Format results: convert numbers back to strings for display in inputs
    const uiResults = results.map(item => ({
        ...item,
        baseMin: '', // Local base min for this row
        baseMax: '', // Local base max for this row
        limits: Object.fromEntries(
            Object.entries(item.limits).map(([key, limit]) => [
                key,
                { min: limit.min !== undefined && limit.min !== null ? limit.min : '', 
                  max: limit.max !== undefined && limit.max !== null ? limit.max : '' }
            ])
        )
    }));
    
    // Auto-fill currency if results have 2+ items with same currency and currency filter is empty
    if (!searchFilters.currency && results.length >= 2) {
      const firstCurrency = results[0].currency;
      const allSameCurrency = results.every(item => item.currency === firstCurrency);
      if (allSameCurrency) {
        setSearchFilters(prev => ({ ...prev, currency: firstCurrency }));
      }
    }
    
    setSearchResults(JSON.parse(JSON.stringify(uiResults))); 
    setHasSearched(true);
    setSearchBaseMin('');
    setSearchBaseMax('');
  };

  // Logic: Single Row Auto Calc
  const handleSingleBatchCalc = (index) => {
    const newResults = [...searchResults];
    const item = newResults[index];
    
    if (item.status === 'Disable') {
        return showNotification('Cannot calculate for disabled games.', 'error');
    }
    
    const baseMinVal = parseNumber(item.baseMin);
    const baseMaxVal = parseNumber(item.baseMax);
    
    if (baseMinVal === '' && baseMaxVal === '') {
        return showNotification('Please enter Base Min or Max Limit for this row first.', 'error');
    }

    const gameFields = GAME_LIMIT_FIELDS[item.game]?.fields || [];
    
    gameFields.forEach(fieldName => {
        // Initialize field if it doesn't exist
        if (!item.limits[fieldName]) {
            item.limits[fieldName] = { min: '', max: '' };
        }
        
        // Min Calculation
        if (baseMinVal !== '') {
            const minRatio = MIN_RATIOS[fieldName] !== undefined ? MIN_RATIOS[fieldName] : 100;
            let calcMin = Math.floor(Number(baseMinVal) * (minRatio / 100));
            if (item.minChip > 0 && calcMin < item.minChip) {
                calcMin = item.minChip;
            }
            item.limits[fieldName].min = calcMin;
        }
        
        // Max Calculation
        if (baseMaxVal !== '') {
            // Check if Base Max <= Base Min
            if (baseMinVal !== '' && Number(baseMaxVal) <= Number(baseMinVal)) {
                item.limits[fieldName].max = 1;
            } else {
                const maxRatio = MAX_RATIOS[fieldName] !== undefined ? MAX_RATIOS[fieldName] : 100;
                let calcMax = Math.floor(Number(baseMaxVal) * (maxRatio / 100));
                item.limits[fieldName].max = calcMax;
            }
        }
    });
    
    setSearchResults(newResults);
    showNotification(`Applied calculation to ${item.game} (${item.id})`);
  };

  // Logic: Modify inside Search Results
  const handleResultChange = (index, fieldPath, value) => {
    const newResults = [...searchResults];
    let current = newResults[index];
    for (let i = 0; i < fieldPath.length - 1; i++) {
      current = current[fieldPath[i]];
    }
    current[fieldPath[fieldPath.length - 1]] = value;
    setSearchResults(newResults);
  };

  // Logic: Batch Auto Calc for Search Results
  const handleSearchBatchCalc = () => {
    const baseMinVal = parseNumber(searchBaseMin);
    const baseMaxVal = parseNumber(searchBaseMax);
    // 檢查錯誤條件
    let hasError = false;
    if (searchBaseMin !== '' && searchFilters.currency && MIN_CHIP_DEFAULTS[searchFilters.currency] && Number(searchBaseMin) < MIN_CHIP_DEFAULTS[searchFilters.currency]) {
      hasError = true;
    }
    if (searchBaseMax !== '' && searchBaseMin !== '' && Number(searchBaseMax) <= Number(searchBaseMin)) {
      hasError = true;
    }
    if (hasError) {
      showNotification('Failed to apply.', 'error');
      return;
    }
    const newResults = searchResults.map(item => {
      const newItem = JSON.parse(JSON.stringify(item)); // Deep copy
      
      // Skip calculation for disabled games
      if (item.status === 'Disable') {
        return newItem;
      }
      
      // Update baseMin and baseMax for each item
      if (baseMinVal !== '') {
        newItem.baseMin = searchBaseMin;
      }
      if (baseMaxVal !== '') {
        newItem.baseMax = searchBaseMax;
      }
      
      const gameFields = GAME_LIMIT_FIELDS[item.game]?.fields || [];
      gameFields.forEach(fieldName => {
        // Initialize field if it doesn't exist
        if (!newItem.limits[fieldName]) {
          newItem.limits[fieldName] = { min: '', max: '' };
        }
        
        // Min Calculation
        if (baseMinVal !== '') {
          const minRatio = MIN_RATIOS[fieldName] !== undefined ? MIN_RATIOS[fieldName] : 100;
          let calcMin = Math.floor(Number(baseMinVal) * (minRatio / 100));
          if (item.minChip > 0 && calcMin < item.minChip) {
            calcMin = item.minChip;
          }
          newItem.limits[fieldName].min = calcMin;
        }
        // Max Calculation
        if (baseMaxVal !== '') {
          const maxRatio = MAX_RATIOS[fieldName] !== undefined ? MAX_RATIOS[fieldName] : 100;
          let calcMax = Math.floor(Number(baseMaxVal) * (maxRatio / 100));
          newItem.limits[fieldName].max = calcMax;
        }
      });
      return newItem;
    });
    setSearchResults(newResults);
    showNotification('Successfully applied to all games.', 'success');
  };

  // Logic: Save All Modified Rows
  const handleSaveAll = () => {
    let hasError = false;
    const updatedData = [...data];
    let updateCount = 0;
    const errorItems = [];

    // Validate all rows first
    for (const item of searchResults) {
        let itemHasError = false;
        Object.entries(item.limits).forEach(([key, val]) => {
            const minValNum = parseNumber(val.min) === '' ? null : Number(parseNumber(val.min));
            const maxValNum = parseNumber(val.max) === '' ? null : Number(parseNumber(val.max));
            if (minValNum !== null && minValNum < item.minChip) { hasError = true; itemHasError = true; }
            if (minValNum !== null && maxValNum !== null && maxValNum < minValNum) { hasError = true; itemHasError = true; }
        });
        if (itemHasError) {
            errorItems.push(`${item.id} - ${item.game}`);
        }
    }

    if (hasError) {
        setSaveAllStatus('failed');
        setTimeout(() => setSaveAllStatus(null), 3000);
        const errorList = errorItems.join(', ');
        return showNotification(`Save Failed: Please check for errors {${errorList}}`, 'error');
    }

    // Apply updates
    searchResults.forEach(item => {
        const savePayload = JSON.parse(JSON.stringify(item));
        Object.keys(savePayload.limits).forEach(key => {
            savePayload.limits[key].min = parseNumber(savePayload.limits[key].min) !== '' ? Number(parseNumber(savePayload.limits[key].min)) : '';
            savePayload.limits[key].max = parseNumber(savePayload.limits[key].max) !== '' ? Number(parseNumber(savePayload.limits[key].max)) : '';
        });

        const index = updatedData.findIndex(d => d.id === savePayload.id && d.game === savePayload.game && d.website === savePayload.website && d.currency === savePayload.currency);
        if (index !== -1) {
            updatedData[index] = savePayload;
            updateCount++;
        }
    });

    setData(updatedData);
    
    // Generate success message with IDs
    const uniqueIds = [...new Set(searchResults.map(item => item.id))];
    let successMsg = '';
    if (uniqueIds.length === 1) {
      // Single ID - check if all games or specific games
      const sameIdItems = searchResults.filter(item => item.id === uniqueIds[0]);
      if (sameIdItems.length >= 7) {
        successMsg = `Bet Limit ${uniqueIds[0]} updated successfully for all games!`;
      } else {
        successMsg = `Bet Limit ${uniqueIds[0]} updated successfully!`;
      }
    } else {
      // Multiple IDs
      successMsg = `Bet Limits ${uniqueIds.join(', ')} updated successfully!`;
    }
    
    showNotification(successMsg);
    setSaveAllStatus('success');
    setTimeout(() => setSaveAllStatus(null), 3000);
  };

  // Logic: Toggle Status
  const handleToggleStatus = (index) => {
    const newResults = [...searchResults];
    newResults[index].status = newResults[index].status === 'Enable' ? 'Disable' : 'Enable';
    setSearchResults(newResults);
  };

  // Logic: Save Modified Row
  const handleSaveRow = (index) => {
    const item = searchResults[index];
    
    let hasError = false;
    Object.entries(item.limits).forEach(([key, val]) => {
        const minValNum = parseNumber(val.min) === '' ? null : Number(parseNumber(val.min));
        const maxValNum = parseNumber(val.max) === '' ? null : Number(parseNumber(val.max));
        
        // Check if Min ??Min Chip
        if (minValNum !== null && minValNum < item.minChip) hasError = true;
        // Check if Max ??Min
        if (minValNum !== null && maxValNum !== null && maxValNum < minValNum) hasError = true;
    });

    if (hasError) {
        setSaveStatus(prev => ({ ...prev, [item.id]: 'failed' }));
        setTimeout(() => setSaveStatus(prev => { const n = {...prev}; delete n[item.id]; return n; }), 3000);
        return showNotification(`Save Failed: Please check for errors {${item.id} - ${item.game}}`, 'error');
    }

    // Prepare payload for saving
    const savePayload = JSON.parse(JSON.stringify(item));
    // Remove UI-only fields
    delete savePayload.baseMin;
    delete savePayload.baseMax;

    Object.keys(savePayload.limits).forEach(key => {
        savePayload.limits[key].min = parseNumber(savePayload.limits[key].min) !== '' ? Number(parseNumber(savePayload.limits[key].min)) : '';
        savePayload.limits[key].max = parseNumber(savePayload.limits[key].max) !== '' ? Number(parseNumber(savePayload.limits[key].max)) : '';
    });

    // Check for changes
    const originalItem = data.find(d => d.id === item.id && d.game === item.game && d.website === item.website && d.currency === item.currency);
    if (originalItem) {
        // Compare limits and status
        const isLimitsChanged = JSON.stringify(savePayload.limits) !== JSON.stringify(originalItem.limits);
        const isStatusChanged = savePayload.status !== originalItem.status;
        
        if (!isLimitsChanged && !isStatusChanged) {
             return showNotification('No changes detected.', 'info');
        }
    }

    const newData = data.map(d => (d.id === savePayload.id && d.game === savePayload.game && d.website === savePayload.website && d.currency === savePayload.currency) ? savePayload : d);
    setData(newData);
    showNotification(`Bet Limit ${item.id} updated successfully!`);
    setSaveStatus(prev => ({ ...prev, [item.id]: 'success' }));
    setTimeout(() => setSaveStatus(prev => { const n = {...prev}; delete n[item.id]; return n; }), 3000);
  };

  return (
    // Use max-w-7xl wide container, suitable for admin UI
    <div className="min-h-screen bg-gray-50 text-gray-800 font-sans p-6">
      
      {/* Header */}
      <div className="max-w-7xl mx-auto mb-6">
      </div>

      {/* Main Content Card */}
      <div className="max-w-7xl mx-auto bg-white rounded-lg shadow-xl border border-gray-200 overflow-hidden mb-6">
        
        {/* Tabs */}
        <div className="flex border-b border-gray-200">
          <button
            onClick={() => setActiveTab('search')}
            className={`flex-1 py-4 px-6 text-sm font-semibold flex items-center justify-center gap-2 transition-colors rounded-t-lg ${activeTab === 'search' ? 'bg-blue-100 text-blue-800 border-b-2 border-blue-600' : 'text-gray-500 hover:text-blue-700 bg-white'}`}
          >
            Search & Modify
          </button>
          <button
            onClick={() => setActiveTab('create')}
            className={`flex-1 py-4 px-6 text-sm font-semibold flex items-center justify-center gap-2 transition-colors rounded-t-lg ${activeTab === 'create' ? 'bg-blue-100 text-blue-800 border-b-2 border-blue-600' : 'text-gray-500 hover:text-blue-700 bg-white'}`}
          >
            <Plus className="w-4 h-4" /> Create New Bet Limit
          </button>
        </div>

        <div className="p-6">
          {/* Notification */}
          {notification && (
            <div className={`mb-4 p-4 rounded-md flex items-center justify-between gap-2 ${notification.type === 'error' ? 'bg-red-50 text-red-700' : 'bg-green-50 text-green-700'}`}>
              <div className="flex items-center gap-2">
                <AlertCircle className="w-5 h-5" />
                <div className="text-sm">{notification.msg}</div>
              </div>
              <div>
                <button
                  onClick={() => { if (notificationTimerRef.current) { clearTimeout(notificationTimerRef.current); notificationTimerRef.current = null; } setNotification(null); }}
                  className="text-xs px-2 py-1 rounded bg-white/10 hover:bg-white/20"
                  aria-label="Close notification"
                >
                  Close
                </button>
              </div>
            </div>
          )}

          {/* === CREATE TAB === */}
          {activeTab === 'create' && (
            <div className="space-y-8">
              {/* Batch Mode Toggle */}
              <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <input
                      type="checkbox"
                      id="batchMode"
                      checked={batchMode}
                      onChange={(e) => {
                        setBatchMode(e.target.checked);
                        if (e.target.checked) {
                          setNewLimit(prev => ({ ...prev, game: '' }));
                        }
                      }}
                      className="w-4 h-4 text-blue-600 border-blue-300 rounded focus:ring-blue-500"
                    />
                    <label htmlFor="batchMode" className="text-sm font-medium text-blue-900">
                      Create Limits for All Games
                    </label>
                  </div>
                  {/* 已移除：批次/單筆建立提示文字 */}
                </div>
              </div>

              {/* Top Form: Basic Information */}
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-6 items-start pb-6 border-b border-gray-100">
                <div className="col-span-1">
                  <label className="block text-sm font-medium text-gray-700 mb-1">Game <span className="text-red-500">*</span></label>
                  <select 
                    className={`w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2 border ${newLimit.game === '' ? 'text-gray-400' : 'text-gray-800'}`}
                    value={newLimit.game}
                    onChange={(e) => {
                      const selectedGame = e.target.value;
                      setNewLimit(prev => ({ 
                        ...prev, 
                        game: selectedGame,
                        limits: getInitialLimitsForGame(selectedGame)
                      }));
                    }}
                    disabled={batchMode}
                  >
                    <option value="" disabled className="text-gray-400">{batchMode ? 'All Games' : 'Select Game'}</option>
                    {!batchMode && GAMES.map(g => <option key={g} value={g} className="text-gray-800">{g}</option>)}
                  </select>
                  {/* ...removed batch mode helper text... */}
                </div>

                <div className="col-span-1">
                  <label className="block text-sm font-medium text-gray-700 mb-1">Website <span className="text-red-500">*</span></label>
                  <select 
                    className={`w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2 border ${newLimit.website === '' ? 'text-gray-400' : 'text-gray-800'}`}
                    value={newLimit.website}
                    onChange={(e) => setNewLimit({ ...newLimit, website: e.target.value })}
                  >
                    <option value="" disabled className="text-gray-400">Select Website</option>
                    {WEBSITES.map(w => <option key={w} value={w} className="text-gray-800">{w}</option>)}
                  </select>
                </div>
                
                <div className="col-span-1">
                  <label className="block text-sm font-medium text-gray-700 mb-1">Currency <span className="text-red-500">*</span></label>
                  <select 
                    className={`w-full border-gray-300 rounded-md shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2 border ${newLimit.currency === '' ? 'text-gray-400' : 'text-gray-800'}`}
                    value={newLimit.currency}
                    onChange={(e) => setNewLimit({ ...newLimit, currency: e.target.value })}
                  >
                    <option value="" disabled className="text-gray-400">Select Currency</option> 
                    {CURRENCIES.map(c => <option key={c} value={c} className="text-gray-800">{CURRENCY_DISPLAY[c] || c}</option>)}
                  </select>
                </div>

                <div className="col-span-1 flex flex-col items-start gap-1">
                    <label className="mb-1 text-xs font-semibold text-gray-600 tracking-wider">Bet Limit ID</label>
                    <div className="flex w-full gap-2">
                         <input
                            type="text"
                            value={newLimit.id}
                            onChange={(e) => setNewLimit({ ...newLimit, id: e.target.value })}
                            placeholder=""
                            className="w-full px-4 py-2 border border-gray-300 rounded-lg text-base bg-white focus:ring-blue-500 focus:border-blue-500 focus:outline-none focus:ring-2" style={{height: '36.5px'}} 
                        />
                         <button 
                            onClick={generateId}
                            className="px-4 py-2 font-semibold rounded-lg transition-colors border border-blue-200 flex items-center justify-center" style={{height: '36.5px', backgroundColor: 'rgb(30, 141, 184)', color: 'white', lineHeight: 'normal'}}
                            title="Auto"
                        >
                            Auto
                         </button>
                    </div>
                </div>


              </div>

              {/* Quick Calc Section */}
              <div className="bg-blue-50 border border-blue-100 p-4 rounded-lg">
                <div className="flex items-center gap-2 mb-3">
                   <RefreshCw className="w-4 h-4 text-blue-600" />
                   <h3 className="text-sm font-bold text-blue-800">Quick Auto-Calculation</h3>
                </div>
                <div className="flex flex-col sm:flex-row gap-4 items-center">
                  <div className="w-full sm:w-48">
                    <label className="text-xs text-blue-600 font-semibold">Base Min Limit (100% Rate)</label>
                    <input 
                      type="text" 
                      className={`w-full border rounded p-2 text-right ${baseMin !== '' && newLimit.minChip > 0 && Number(baseMin) < newLimit.minChip ? 'border-red-500 bg-red-50' : 'border-blue-200'}`}
                      placeholder="e.g. 100"
                      value={formatNumber(baseMin)} 
                      onChange={(e) => handleBaseValueChange('min', e.target.value)}
                      disabled={!(newLimit.website && newLimit.currency)}
                    />
                    {baseMin !== '' && newLimit.minChip > 0 && Number(baseMin) < newLimit.minChip && (
                      <div className="text-[9px] text-red-600 leading-tight text-right font-medium mt-1">
                        Must be ≥ Min Chip
                      </div>
                    )}
                  </div>
                  <div className="w-full sm:w-48">
                    <label className="text-xs text-blue-600 font-semibold">Base Max Limit (100% Rate)</label>
                    <input 
                      type="text" 
                      className={`w-full border rounded p-2 text-right border-blue-200 ${baseMax !== '' && baseMin !== '' && Number(baseMax) <= Number(baseMin) ? 'border-red-500 bg-red-50' : ''}`}
                      placeholder="e.g. 10,000"
                      value={formatNumber(baseMax)} 
                      onChange={(e) => handleBaseValueChange('max', e.target.value)}
                      disabled={!(newLimit.website && newLimit.currency)}
                    />
                    {baseMax !== '' && baseMin !== '' && Number(baseMax) <= Number(baseMin) && (
                      <div className="text-[9px] text-red-600 leading-tight text-right font-medium mt-1">
                        Must be &gt; Min Limit
                      </div>
                    )}
                  </div>
                  <div className="flex-1 flex justify-end w-full">
                    <div className="bg-gray-100 p-3 rounded-md border border-gray-200 min-w-[220px] max-w-xs">
                      <label className="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-1 flex items-center gap-1">
                        <Info className="w-3 h-3" /> Currency MIN CHIP
                      </label>
                      <div className="flex items-center gap-2">
                        <span className="text-gray-400 text-xs">Value:</span>
                        <input 
                          type="text"
                          readOnly
                          className={`w-full bg-transparent border-b border-gray-300 focus:outline-none text-sm font-medium text-gray-500 cursor-not-allowed font-semibold ${!(newLimit.website && newLimit.currency) ? 'opacity-60' : ''}`}
                          value={newLimit.currency ? formatNumber(newLimit.minChip) : ''}
                        />
                      </div>
                      <p className="text-[10px] text-gray-400 mt-1">Min Limit must be ≧ this value.</p>
                    </div>
                  </div>
                </div>
              </div>

              {/* Limits Matrix */}
              <div>
                <div className="flex justify-end items-center mb-3">
                  <div className="flex items-center gap-2">
                    {createStatus === 'success' && <span className="text-sm text-green-700 font-bold bg-green-100 px-2 py-1 rounded">Save Successful</span>}
                    {createStatus === 'failed' && <span className="text-sm text-red-700 font-bold bg-red-100 px-2 py-1 rounded">Failed</span>}
                    <button 
                        onClick={handleCreateSubmit}
                        className="px-6 py-2 font-semibold rounded-lg transition-colors flex items-center gap-2 border border-blue-200 disabled:opacity-60 disabled:cursor-not-allowed" style={{backgroundColor: 'rgb(30, 141, 184)', color: 'white', height: '36.5px'}}
                    >
                        <Save className="w-4 h-4" /> {batchMode ? 'Save All' : 'Save New Limit'}
                    </button>
                  </div>
                </div>
                
                {batchMode ? (
                  <div className="space-y-8">
                    {GAMES.map(game => (
                      <div key={game} className="border rounded-lg p-4 bg-gray-50">
                        <div className="mb-3 pb-2 border-b border-gray-200">
                            <span className="text-sm font-semibold px-2 py-1 rounded" style={{color: 'rgb(30,64,175)', backgroundColor: 'rgb(191,219,254)'}}>{game}</span>
                        </div>
                        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 xl:grid-cols-6 gap-3">
                          {GAME_LIMIT_FIELDS[game].fields.map(fieldName => {
                            const fieldConfig = GAME_LIMIT_FIELDS[game].config[fieldName];
                            const isMain = fieldConfig.isMain;
                            const minRatio = MIN_RATIOS[fieldName] || 100;
                            const maxRatio = MAX_RATIOS[fieldName] || 100;
                            return (
                              <LimitInputGroup 
                                key={`${game}-${fieldName}`}
                                title={fieldConfig.displayName}
                                isMain={isMain}
                                minChipLimit={newLimit.minChip}
                                disabled={!(newLimit.website && newLimit.currency)}
                                minRatio={minRatio}
                                maxRatio={maxRatio}
                                minVal={newLimit.limits[game]?.[fieldName]?.min || ''}
                                maxVal={newLimit.limits[game]?.[fieldName]?.max || ''}
                                baseMinLimit={baseMin}
                                onMinChange={(val) => {
                                  setNewLimit(prev => ({
                                    ...prev,
                                    limits: { 
                                      ...prev.limits, 
                                      [game]: { 
                                        ...prev.limits[game], 
                                        [fieldName]: { ...prev.limits[game]?.[fieldName], min: val } 
                                      } 
                                    }
                                  }));
                                }}
                                onMaxChange={(val) => {
                                  setNewLimit(prev => ({
                                    ...prev,
                                    limits: { 
                                      ...prev.limits, 
                                      [game]: { 
                                        ...prev.limits[game], 
                                        [fieldName]: { ...prev.limits[game]?.[fieldName], max: val } 
                                      } 
                                    }
                                  }));
                                }}
                              />
                            );
                          })}
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  // 單一遊戲模式，立即顯示該遊戲注區
                  <div className="space-y-8">
                    {newLimit.game && GAME_LIMIT_FIELDS[newLimit.game] && (
                      <div className="border rounded-lg p-4 bg-gray-50">
                        <div className="mb-3 pb-2 border-b border-gray-200">
                            <span className="text-sm font-semibold px-2 py-1 rounded" style={{color: 'rgb(30,64,175)', backgroundColor: 'rgb(191,219,254)'}}>{newLimit.game}</span>
                        </div>
                        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 xl:grid-cols-6 gap-3">
                          {GAME_LIMIT_FIELDS[newLimit.game].fields.map(fieldName => {
                            const fieldConfig = GAME_LIMIT_FIELDS[newLimit.game].config[fieldName];
                            const isMain = fieldConfig.isMain;
                            const minRatio = MIN_RATIOS[fieldName] || 100;
                            const maxRatio = MAX_RATIOS[fieldName] || 100;
                            return (
                              <LimitInputGroup 
                                key={`${newLimit.game}-${fieldName}`}
                                title={fieldConfig.displayName}
                                isMain={isMain}
                                minChipLimit={newLimit.minChip}
                                disabled={!(newLimit.website && newLimit.currency)}
                                minRatio={minRatio}
                                maxRatio={maxRatio}
                                minVal={newLimit.limits[newLimit.game]?.[fieldName]?.min || ''}
                                maxVal={newLimit.limits[newLimit.game]?.[fieldName]?.max || ''}
                                baseMinLimit={baseMin}
                                onMinChange={(val) => {
                                  setNewLimit(prev => ({
                                    ...prev,
                                    limits: { 
                                      ...prev.limits, 
                                      [newLimit.game]: { 
                                        ...prev.limits[newLimit.game], 
                                        [fieldName]: { ...prev.limits[newLimit.game]?.[fieldName], min: val } 
                                      } 
                                    }
                                  }));
                                }}
                                onMaxChange={(val) => {
                                  setNewLimit(prev => ({
                                    ...prev,
                                    limits: { 
                                      ...prev.limits, 
                                      [newLimit.game]: { 
                                        ...prev.limits[newLimit.game], 
                                        [fieldName]: { ...prev.limits[newLimit.game]?.[fieldName], max: val } 
                                      } 
                                    }
                                  }));
                                }}
                              />
                            );
                          })}
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>


            </div>
          )}

          {/* === SEARCH TAB === */}
          {activeTab === 'search' && (
            <div className="space-y-6">
              {/* Search Bar */}
              <div className="bg-gray-50 p-4 rounded-lg border border-gray-200 grid grid-cols-1 md:grid-cols-5 gap-4 items-start">
                 <div className="col-span-1">
                  <label className="block text-xs font-bold text-gray-500 mb-1">Website <span className="text-red-500">*</span></label>
                  <select 
                    className={`w-full text-sm border-gray-300 rounded-md shadow-sm p-2 border ${searchFilters.website === '' ? 'text-gray-400' : 'text-gray-800'}`}
                    value={searchFilters.website}
                    onChange={(e) => setSearchFilters(prev => ({...prev, website: e.target.value}))}
                  >
                    <option value="" disabled className="text-gray-400">Select Website</option>
                    {WEBSITES.map(w => <option key={w} value={w} className="text-gray-800">{w}</option>)}
                  </select>
                </div>
                <div className="col-span-1">
                  <label className="block text-xs font-bold text-gray-500 mb-1">Currency (Optional)</label>
                  <select 
                    className={`w-full text-sm border-gray-300 rounded-md shadow-sm p-2 border ${searchFilters.currency === '' ? 'text-gray-400' : 'text-gray-800'}`}
                    value={searchFilters.currency}
                    onChange={(e) => setSearchFilters(prev => ({...prev, currency: e.target.value}))}
                  >
                    <option value="">All Currencies</option>
                    {CURRENCIES.map(c => <option key={c} value={c} className="text-gray-800">{CURRENCY_DISPLAY[c] || c}</option>)}
                  </select>
                  {searchFilters.currency && MIN_CHIP_DEFAULTS[searchFilters.currency] && (
                    <div className="text-[10px] text-red-600 mt-1 font-medium">
                      {/* 已移除：Min Limit must be ≧ Currency min chip 提示 */}
                    </div>
                  )}
                </div>
                <div className="col-span-1">
                  <label className="block text-xs font-bold text-gray-500 mb-1">Game (Optional)</label>
                  <select 
                    className={`w-full text-sm border-gray-300 rounded-md shadow-sm p-2 border ${searchFilters.game === '' ? 'text-gray-400' : 'text-gray-800'}`}
                    value={searchFilters.game}
                    onChange={(e) => setSearchFilters(prev => ({...prev, game: e.target.value}))}
                  >
                    <option value="">All Games</option>
                    {GAMES.map(g => <option key={g} value={g} className="text-gray-800">{g}</option>)}
                  </select>
                </div>
                <div className="col-span-1">
                   <div className="flex flex-col w-full">
                        <label className="mb-1 text-xs font-semibold text-gray-600 tracking-wider">Bet Limit ID</label>
                        <input
                            type="text"
                            placeholder="e.g. 10001"
                            value={searchFilters.id}
                            onChange={(e) => setSearchFilters(prev => ({...prev, id: e.target.value}))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm bg-white focus:ring-blue-500 focus:border-blue-500 focus:outline-none focus:ring-2"
                        />
                    </div>
                </div>
                <div className="col-span-1">
                  <button 
                    onClick={handleSearch}
                    className="w-full bg-gray-800 text-white px-4 py-2 rounded-md font-medium hover:bg-gray-900 transition-colors flex justify-center items-center gap-2"
                  >
                    <Search className="w-4 h-4" /> Search
                  </button>
                </div>
              </div>

              {/* Search Results Display */}
              {hasSearched && (
                <div className="mt-6">
                  
                  {/* Batch Modification Panel */}
                    {searchResults.length > 1 &&
                      searchResults.every(item => item.id === searchResults[0].id && item.currency === searchResults[0].currency) && (
                    <div className="bg-blue-50 border border-blue-100 p-4 rounded-lg mb-6">
                      <div className="flex items-center gap-2 mb-3">
                      <RefreshCw className="w-4 h-4 text-blue-600" />
                      <h3 className="text-sm font-bold text-blue-800">Quick Auto-Calculation（All Games）</h3>
                      </div>
                      <div className="flex flex-col sm:flex-row gap-4 items-start">
                        <div className="w-full sm:w-48">
                          <label className="text-xs text-blue-600 font-semibold">Base Min Limit (100%)</label>
                          <input 
                          type="text" 
                          className={`w-full border rounded p-2 text-right ${searchBaseMin !== '' && searchFilters.currency && MIN_CHIP_DEFAULTS[searchFilters.currency] && Number(searchBaseMin) < MIN_CHIP_DEFAULTS[searchFilters.currency] ? 'border-red-500 bg-red-50' : 'border-blue-200'}`}
                          placeholder="e.g. 100"
                          value={formatNumber(searchBaseMin)} 
                          onChange={(e) => setSearchBaseMin(parseNumber(e.target.value))}
                          />
                          {searchBaseMin !== '' && searchFilters.currency && MIN_CHIP_DEFAULTS[searchFilters.currency] && Number(searchBaseMin) < MIN_CHIP_DEFAULTS[searchFilters.currency] && (
                            <div className="text-[9px] text-red-600 leading-tight text-right font-medium mt-1">
                            Must be ≥ Min Chip
                            </div>
                          )}
                        </div>
                        <div className="w-full sm:w-48">
                          <label className="text-xs text-blue-600 font-semibold">Base Max Limit (100%)</label>
                          <input 
                            type="text" 
                            className={`w-full border rounded p-2 text-right border-blue-200 ${searchBaseMax !== '' && searchBaseMin !== '' && Number(searchBaseMax) <= Number(searchBaseMin) ? 'border-red-500 bg-red-50' : ''}`}
                            placeholder="e.g. 10,000"
                            value={formatNumber(searchBaseMax)} 
                            onChange={(e) => setSearchBaseMax(parseNumber(e.target.value))}
                          />
                          {searchBaseMax !== '' && searchBaseMin !== '' && Number(searchBaseMax) <= Number(searchBaseMin) && (
                            <div className="text-[9px] text-red-600 leading-tight text-right font-medium mt-1">
                              Must be &gt; Min Limit
                            </div>
                          )}
                        </div>
                        <div className="w-full sm:w-48">
                          <label className="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-1 flex items-center gap-1">
                            <Info className="w-3 h-3" /> Currency MIN CHIP
                          </label>
                          <div className="flex items-center gap-2">
                            <span className="text-gray-400 text-xs">Value:</span>
                            <input
                              type="text"
                              readOnly
                              className={`w-full bg-transparent border-b border-gray-300 focus:outline-none text-sm font-medium text-gray-500 cursor-not-allowed font-semibold ${!(searchFilters.website && searchFilters.currency) ? 'opacity-60' : ''}`}
                              value={searchFilters.currency ? formatNumber(MIN_CHIP_DEFAULTS[searchFilters.currency]) : ''}
                            />
                          </div>
                          <p className="text-[10px] text-gray-400 mt-1">Min Limit must be ≧ this value.</p>
                        </div>
                        <button 
                          onClick={handleSearchBatchCalc}
                          className="bg-blue-600 text-white px-4 py-2 rounded-md font-medium hover:bg-blue-700 transition-colors text-sm h-[38px] mt-6"
                        >
                          Apply to All Games
                        </button>
                        <div className="text-xs text-blue-500 pb-2 flex-1 mt-6">
                          {/* 已移除：Applies calculated limits to all ... games below. */}
                        </div>
                      </div>
                    </div>
                    )}

                  <div className="flex justify-between items-center mb-4">
                    <h3 className="text-sm font-bold text-gray-700">Search Results ({searchResults.length})</h3>
                    {searchResults.length > 0 && (
                        <div className="flex items-center gap-2">
                            {saveAllStatus === 'success' && <span className="text-sm text-green-700 font-bold bg-green-100 px-2 py-1 rounded">Saved!</span>}
                            {saveAllStatus === 'failed' && <span className="text-sm text-red-700 font-bold bg-red-100 px-2 py-1 rounded">Failed</span>}
                            <button 
                                onClick={handleSaveAll}
                                className="bg-green-600 text-white px-4 py-2 rounded-md font-medium hover:bg-green-700 transition-colors flex items-center gap-2 text-sm"
                            >
                                <Save className="w-4 h-4" /> Save All Changes
                            </button>
                        </div>
                    )}
                  </div>
                  
                  {searchResults.length === 0 ? (
                     <div className="text-center py-10 bg-white border border-dashed rounded text-gray-400">No results found.</div>
                  ) : (
                    <div className="space-y-6">
                      {searchResults.map((item, idx) => (
                        <div key={item.id} className={`bg-white border border-gray-200 rounded-lg shadow-sm overflow-hidden hover:shadow-md transition-shadow ${item.status !== 'Enable' ? 'grayscale opacity-60' : ''}`}>
                          {/* Row Header */}
                          <div className="bg-gray-50 px-4 py-2 border-b border-gray-200 flex flex-wrap gap-4 items-center justify-between">
                            <div className="flex items-center gap-4">
                              <span className="font-mono font-bold text-blue-700 bg-blue-50 px-2 py-1 rounded text-sm">{item.id}</span>
                              <span className="text-sm font-semibold text-purple-700 bg-purple-50 px-2 py-1 rounded">{item.game}</span>
                              <span className="text-sm font-semibold text-gray-700">{item.currency}</span>
                              <span className="text-sm text-gray-500 border-l pl-4 border-gray-300">
                                Currency Min Chip: <span className="text-gray-500 font-semibold">{formatNumber(item.minChip)}</span>
                              </span>
                            </div>
                              <div className="flex items-center gap-4">
                                <div className="flex items-center gap-2">
                                  <span className="text-xs font-bold text-gray-500">Status:</span>
                                  <button
                                    onClick={() => handleToggleStatus(idx)}
                                    className={`px-3 py-1 text-xs font-semibold rounded transition-colors border ${item.status === 'Enable' ? 'bg-green-50 text-green-700 border-green-200 hover:bg-green-100' : 'bg-red-50 text-red-600 border-red-200 hover:bg-red-100'}`}
                                  >
                                    {item.status}
                                  </button>
                                </div>
                                  <div className="flex items-center gap-2">
                                  {saveStatus[item.id] === 'success' && <span className="text-sm text-green-700 font-bold bg-green-100 px-2 py-1 rounded">Saved!</span>}
                                  {saveStatus[item.id] === 'failed' && <span className="text-sm text-red-700 font-bold bg-red-100 px-2 py-1 rounded">Failed</span>}
                                  <button 
                                    onClick={() => handleSaveRow(idx)}
                                    className="px-3 py-1 bg-blue-100 text-blue-700 font-semibold rounded-lg hover:bg-blue-200 transition-colors flex items-center gap-1 border border-blue-200 text-xs disabled:bg-blue-50 disabled:text-blue-300 disabled:cursor-not-allowed"
                                  >
                                    <Save className="w-3 h-3" /> Save
                                  </button>
                                  </div>
                            </div>
                          </div>

                          {/* Editable Grid */}
                          <div className="p-4 flex gap-4">
                            {/* Left Panel: Quick Auto-Calculation */}
                            <div className="w-48 flex-shrink-0 space-y-3 bg-blue-50 p-3 rounded border border-blue-100">
                                <div>
                                    <label className="block text-xs font-bold text-blue-700 mb-1">Base Min Limit (100%)</label>
                                    <input 
                                        type="text" 
                                        className="w-full border border-blue-200 rounded p-1.5 text-right text-sm"
                                        placeholder=""
                                        value={formatNumber(item.baseMin)}
                                        onChange={(e) => handleResultChange(idx, ['baseMin'], parseNumber(e.target.value))}
                                        disabled={item.status === 'Disable'}
                                    />
                                </div>
                                <div>
                                    <label className="block text-xs font-bold text-blue-700 mb-1">Base Max Limit (100%)</label>
                                    <input 
                                        type="text" 
                                        className="w-full border border-blue-200 rounded p-1.5 text-right text-sm"
                                        placeholder=""
                                        value={formatNumber(item.baseMax)}
                                        onChange={(e) => handleResultChange(idx, ['baseMax'], parseNumber(e.target.value))}
                                        disabled={item.status === 'Disable'}
                                    />
                                </div>
                                <button 
                                  onClick={() => handleSingleBatchCalc(idx)}
                                  className="w-full py-1.5 bg-blue-100 text-blue-700 font-semibold rounded-lg hover:bg-blue-200 transition-colors flex justify-center items-center gap-1 border border-blue-200 text-xs disabled:bg-blue-50 disabled:text-blue-300 disabled:cursor-not-allowed"
                                  disabled={item.status === 'Disable'}
                                >
                                  Auto-Calc
                                </button>
                            </div>

                            {/* Right Panel: Scrollable Limits */}
                            <div className="flex-1 overflow-x-auto">
                                <div className="flex gap-2 min-w-max">
                               {/* Render limits based on game */}
                               {GAME_LIMIT_FIELDS[item.game] ? (
                                 GAME_LIMIT_FIELDS[item.game].fields.map(fieldName => {
                                   const fieldConfig = GAME_LIMIT_FIELDS[item.game].config[fieldName];
                                   const isMain = fieldConfig.isMain;
                                   const minRatio = MIN_RATIOS[fieldName] || 100;
                                   const maxRatio = MAX_RATIOS[fieldName] || 100;
                                   
                                   return (
                                     <LimitInputGroup 
                                       key={fieldName}
                                       title={fieldConfig.displayName} 
                                       isMain={isMain} 
                                       minChipLimit={item.minChip}
                                       minRatio={minRatio} 
                                       maxRatio={maxRatio}
                                       minVal={item.limits[fieldName]?.min || ''} 
                                       maxVal={item.limits[fieldName]?.max || ''}
                                       disabled={item.status === 'Disable'}
                                       onMinChange={(v) => handleResultChange(idx, ['limits', fieldName, 'min'], v)}
                                       onMaxChange={(v) => handleResultChange(idx, ['limits', fieldName, 'max'], v)}
                                     />
                                   );
                                 })
                               ) : (
                                 <div className="text-red-500 p-2">Configuration for {item.game} not found</div>
                               )}
                            </div>
                          </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

// Render the app
ReactDOM.render(<App />, document.getElementById('root'));

// Initialize Lucide icons after render
setTimeout(() => {
  if (window.lucide) {
    lucide.createIcons();
  }
}, 100);
